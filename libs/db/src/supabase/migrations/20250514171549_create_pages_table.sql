-- lowercase sql

-- define page_status enum (if not already defined for other tables)
-- checking if type exists to prevent error if run multiple times or if defined elsewhere
do $$
begin
  if not exists (select 1 from pg_type where typname = 'page_status') then
    create type public.page_status as enum ('draft', 'published', 'archived');
  end if;
end
$$;

-- create pages table
create table public.pages (
  id bigint generated by default as identity primary key,
  language_id bigint not null references public.languages(id) on delete cascade,
  author_id uuid references public.profiles(id) on delete set null,
  title text not null,
  slug text not null,
  status public.page_status not null default 'draft',
  meta_title text,
  meta_description text,
  created_at timestamp with time zone not null default now(),
  updated_at timestamp with time zone not null default now()
);

comment on table public.pages is 'stores static pages for the website.';
comment on column public.pages.language_id is 'the language of this page version.';
comment on column public.pages.author_id is 'the user who originally created the page.';
comment on column public.pages.slug is 'url-friendly identifier for the page, unique per language.';
comment on column public.pages.status is 'publication status of the page.';
comment on column public.pages.meta_title is 'seo title for the page.';
comment on column public.pages.meta_description is 'seo description for the page.';

alter table public.pages
  add constraint pages_language_id_slug_key unique (language_id, slug);

alter table public.pages enable row level security;

create policy "pages_are_publicly_readable_when_published"
on public.pages for select
to anon, authenticated
using (status = 'published');

create policy "authors_writers_admins_can_read_own_drafts"
on public.pages for select
to authenticated
using (
  (status <> 'published' and author_id = auth.uid()) or
  (status <> 'published' and public.get_current_user_role() in ('ADMIN', 'WRITER'))
);

create policy "admins_and_writers_can_manage_pages"
on public.pages for all
to authenticated
using (public.get_current_user_role() in ('ADMIN', 'WRITER'))
with check (public.get_current_user_role() in ('ADMIN', 'WRITER'));

create or replace function public.handle_pages_update()
returns trigger
language plpgsql
security definer set search_path = public
as $$
begin
  new.updated_at = now();
  return new;
end;
$$;

create trigger on_pages_update
  before update on public.pages
  for each row
  execute procedure public.handle_pages_update();