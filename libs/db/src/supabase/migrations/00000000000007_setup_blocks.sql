-- 00000000000007_setup_blocks.sql
-- Setup blocks table

CREATE TABLE public.blocks (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  page_id bigint REFERENCES public.pages(id) ON DELETE CASCADE,
  post_id bigint REFERENCES public.posts(id) ON DELETE CASCADE,
  language_id bigint NOT NULL REFERENCES public.languages(id) ON DELETE CASCADE,
  block_type text NOT NULL,
  content jsonb,
  "order" integer NOT NULL DEFAULT 0,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  updated_at timestamp with time zone NOT NULL DEFAULT now(),
  
  CONSTRAINT check_exactly_one_parent CHECK (
    (page_id IS NOT NULL AND post_id IS NULL) OR
    (post_id IS NOT NULL AND page_id IS NULL)
  )
);

COMMENT ON TABLE public.blocks IS 'Stores content blocks for pages and posts.';
COMMENT ON COLUMN public.blocks.block_type IS 'Type of the block, e.g., "text", "image".';
COMMENT ON COLUMN public.blocks.content IS 'JSONB content specific to the block_type.';
COMMENT ON COLUMN public.blocks.order IS 'Sort order of the block.';

-- Indexes
CREATE INDEX idx_blocks_language_id ON public.blocks(language_id);
CREATE INDEX idx_blocks_page_id ON public.blocks(page_id);
CREATE INDEX idx_blocks_post_id ON public.blocks(post_id);

-- Trigger: handle_blocks_update
CREATE OR REPLACE FUNCTION public.handle_blocks_update()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;

CREATE TRIGGER on_blocks_update
  BEFORE UPDATE ON public.blocks
  FOR EACH ROW
  EXECUTE PROCEDURE public.handle_blocks_update();
