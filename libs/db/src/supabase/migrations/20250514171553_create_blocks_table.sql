-- lowercase sql

create table public.blocks (
  id bigint generated by default as identity primary key,
  page_id bigint references public.pages(id) on delete cascade,
  post_id bigint references public.posts(id) on delete cascade,
  language_id bigint not null references public.languages(id) on delete cascade,
  block_type text not null,
  content jsonb,
  "order" integer not null default 0,
  created_at timestamp with time zone not null default now(),
  updated_at timestamp with time zone not null default now(),
  constraint check_exactly_one_parent check (
    (page_id is not null and post_id is null) or
    (post_id is not null and page_id is null)
  )
);

comment on table public.blocks is 'stores content blocks for pages and posts.';
comment on column public.blocks.block_type is 'type of the block, e.g., "text", "image".';
comment on column public.blocks.content is 'jsonb content specific to the block_type.';
comment on column public.blocks.order is 'sort order of the block.';

alter table public.blocks enable row level security;

create policy "blocks_are_readable_if_parent_is_published"
on public.blocks for select
to anon, authenticated
using (
  (page_id is not null and exists(select 1 from public.pages p where p.id = blocks.page_id and p.status = 'published')) or
  (post_id is not null and exists(select 1 from public.posts pt where pt.id = blocks.post_id and pt.status = 'published' and (pt.published_at is null or pt.published_at <= now())))
);

create policy "admins_and_writers_can_manage_blocks"
on public.blocks for all
to authenticated
using (public.get_current_user_role() in ('ADMIN', 'WRITER'))
with check (public.get_current_user_role() in ('ADMIN', 'WRITER'));

create or replace function public.handle_blocks_update()
returns trigger
language plpgsql
security definer set search_path = public
as $$
begin
  new.updated_at = now();
  return new;
end;
$$;

create trigger on_blocks_update
  before update on public.blocks
  for each row
  execute procedure public.handle_blocks_update();